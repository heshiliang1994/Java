红黑树是平衡二叉查找树的一种。为了深入理解红黑树，我们需要从二叉查找树开始讲起。

参考地址：https://www.zhihu.com/search?type=content&q=%E7%BA%A2%E9%BB%91%E6%A0%91

**等比数列求和公式**：

![](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\数列求和公式.jpg)

![](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\等比数列求和公式.jpg)

# 一、二叉查找树 BST

二叉查找树（Binary Search Tree，简称BST）是一棵二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。

在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。

![img](https://pic1.zhimg.com/v2-e64df5b2126506c59bad4604d298d818_b.png)

## 1.BST的查找操作

```Java
T  key = a search key 
Node root = point to the root of a BST  
while(true){
    if(root==null){
        break;
    }
    if(root.value.equals(key)){
        return root;
    }else if(key.compareTo(root.value)<0){
        root = root.left;
    }else{
        root = root.right;
    } 
}
return null;
```

从程序中可以看出，当BST查找的时候，先与当前节点进行比较：

- 如果相等的话就返回当前节点；
- 如果少于当前节点则继续查找当前节点的左节点；
- 如果大于当前节点则继续查找当前节点的右节点。

直到当前节点指针为空或者查找到对应的节点，程序查找结束。

## 2.BST插入操作

```java
Node node = create a new node with specify value
Node root = point the root node of a BST
Node parent = null;

//find the parent node to append the new node
while(true){
   if(root==null)break;
   parent = root;
   if(node.value.compareTo(root.value)<=0){
      root = root.left;  
   }else{
      root = root.right;
   } 
}
if(parent!=null){
   if(node.value.compareTo(parent.value)<=0){//append to left
      parent.left = node;
   }else{//append to right
      parent.right = node;
   }
}
```

插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上。

## 3.BST删除操作

删除操作的步骤如下：

- 查找到要删除的节点。

- 如果待删除的节点是叶子节点，则直接删除。

- 如果待删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。

  

![img](https://pic1.zhimg.com/v2-caf8927ad71613b1f93393931029b5a4_b.png)



## 4.BST存在的问题

BST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。



# 二、红黑树 RBTree

基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。

- AVL树在插入时旋转次数最少为0，最多为2次旋转

红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如**Java的TreeMap和TreeSet**，C++ STL的map、multimap、multiset等。

RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，**Java 8中HashMap的实现也因为用RBTree取代链表**，性能有所提升。

## 1.RBTree的定义

RBTree的定义如下:

- 首先它是一个二叉搜索树

- 任何一个节点都有颜色，黑色或者红色

- 根节点是黑色的

- 父子节点之间不能出现两个连续的红节点

- 任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等

- 空节点被认为是黑色的

数据结构的表示如下：

```java
class  Node<T>{
   public  T value;
   public   Node<T> parent;
   public   boolean isRed;
   public   Node<T> left;
   public   Node<T> right;
}
```

RBTree在理论上还是一棵BST树，但是它在对BST的插入和删除操作时会维持树的平衡，即保证树的高度在[logN,logN+1]（理论上，极端的情况下可以出现RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在O(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是O(logN)。RBTree的查找操作就是BST的查找操作。

## 2.RBTree的旋转操作

旋转操作(Rotate)的目的是使节点颜色符合定义，让RBTree的高度达到平衡。
Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。

![img](https://pic2.zhimg.com/v2-b22d2a98bb0ab3b2dc08316577221e61_b.png)



## 3.RBTree查找

RBTree的查找操作和BST的查找操作是一样的。请参考BST的查找操作代码。

## 4.RBTree的插入操作

首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。

**第一步**: 将红黑树当作一颗二叉查找树，将节点插入。
红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。

**第二步**：将插入的节点着色为"红色"。

为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：

（1）每个节点或者是黑色，或者是红色。

（2）根节点是黑色。

（3）叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]

（4） 如果一个节点是红色的，则它的子节点必须是黑色的。

（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

将插入的节点着色为红色，不会违背"特性(5)"！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o...哈哈

**第三步**: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。

RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（在这里简称插入修复），使得它符合RBTree的定义。

新插入的节点是**红色**的，**插入修复操作如果遇到父节点的颜色为黑则修复操作结束**。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。

插入修复操作分为以下的三种情况，而且新插入的节点的**父节点都是红色的**：

1. 叔叔节点也为红色，调整颜色即可。
2. 叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上，旋转调整颜色即可。
3. 叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上，旋转调整颜色即可。

**插入操作-case1：**

case 1的操作是将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTRee的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。

![img](https://pic1.zhimg.com/v2-85d7be8e54ae9f904d86bf5f5ee3b4bc_b.png)

**插入操作-case2：**

case 2的操作是将B节点进行右旋操作，并且和父节点A互换颜色。通过该修复操作RBTRee的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。

![img](https://pic3.zhimg.com/v2-cd2171937e0ed68bca55214357e6669e_b.png)

**插入操作-case3：**

case 3的操作是将C节点进行左旋，这样就从case 3转换成case 2了，然后针对case 2进行操作处理就行了。case 2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。

![img](https://pic4.zhimg.com/v2-8594087429e54acbbc2aa6ae9da8cc5f_b.png)

## 5.插入操作总结

插入后的修复操作是一个向root节点回溯的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于**case 1操作会将父节点，叔叔节点和祖父节点进行换颜色，有可能会导致祖父节点不平衡(红黑树定义3)。这个时候需要对祖父节点为起点进行调节（向上回溯）**。

祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的追溯的过程中，针对插入的3种情况进行调节。直到符合红黑树的定义为止。直到牵涉的节点都符合了红黑树的定义，修复操作结束。

如果上面的3种情况如果对应的操作是在右子树上，做对应的镜像操作就是了。

## 6.RBTree删除操作

删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使的树符合红黑树的定义，符合定义的红黑树高度是平衡的。

删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕。

**删除修复操作是针对删除黑色节点才有的**，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。

删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。

删除修复操作分为四种情况(删除黑节点后)：

- 待删除的节点的兄弟节点是红色的节点。

- 待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。

- 待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。

- 待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。

**删除操作-case 1：待删除的节点的兄弟节点是红色的节点**

由于兄弟节点是红色节点的时候，无法借调黑节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。

case 1这样转换之后就会变成后面的case 2，case 3，或者case 4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。

之所以要做case 1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。

![img](https://pic4.zhimg.com/v2-46e732e84148b9bca53e995689e9ba9f_b.png)

**删除操作-case 2：待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的**

case 2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整颗树的颜色符合RBTree的定义为止。

case 2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。

![img](https://pic2.zhimg.com/v2-7975d1b235cd30c0bafb716b585ba45d_b.png)

**删除操作-case 3：待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的**

case 3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case 4状态了，在case 4状态下可以将D，E节点都阶段过来，通过将两个节点变成黑色来保证红黑树的整体平衡。

之所以说case-3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，他是通过case 2操作完后向上回溯出现的状态。之所以会出现case 3和后面的case 4的情况，是因为可以通过借用侄子节点的红色，变成黑色来符合红黑树定义4.

![img](https://pic3.zhimg.com/v2-04dbb22d25de3849d902582809198596_b.png)

**删除操作-case 4：待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的**

Case 4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整棵树还是符合RBTree的定义的。

Case 4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义。

![img](https://pic4.zhimg.com/v2-a559407bb4847a140642d16c6301d7db_b.png)



## 7.删除操作的总结

红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。

由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。

对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。

对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。

红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。

# 三、AVL树

？？？AVL树的极端情况要怎么样得到呢？？？

在计算机科学中，AVL树是最先发明的自平衡二叉查找树，在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能通过一次或多次树旋转来重新平衡这个树。AVL树本质是一棵二叉搜索树，它的特点是：

（1）本身首先是一棵二叉搜索树。

（2）带有平衡条件：每个节点的左右子树的高度之差的绝对值（平衡因子）最多为1。

（3）每个节点的子树均为平衡二叉树

为了保证二叉树的平衡，AVL树引入了所谓监督机制，就是在树的某一部分的不平衡超过一个阈值后触发相应的平衡操作，保证树的平衡度在可以接受的范围内。

二叉树的平衡化有两大基础操作：左旋和右旋。左旋，即是逆时针旋转；右旋，即是顺时针旋转。这种旋转在整个平衡化过程中可能进行一次或多次，这两种操作都是失去平衡的最小子树根节点开始的（即离插入节点最近且平衡因子超过1的祖节点）。

## 1、右旋操作

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\21.二叉树.assets\v2-eee97a3e3e45d8cb6668841f6b44191a_720w.jpg)

所谓右旋操作，就是把图中的B节点和C节点进行所谓“父子交换”。在仅有这三个节点时候，是十分简单的。但是当B节点处存在右孩子时，事情就变得有点复杂了。我们通常的操作是：抛弃右孩子，将之和旋转后的节点c相连，称为c的左孩子。这样，我们就能写出对应的代码。

```java
nodeptr_t treeRotateRight(){
    nodeptr_t left = root -> left;
    // 将要被抛弃的节点连接未旋转后的root的左孩子
    root->left = left->right;
    // 调换父子关系
    root->left = left->right;
    left->righ = root;
    
    left->height = max(treeHeight(left->left),treeHeight(left->right))+1;
    root->height = max(treeHeight(root->left),treeHeight(root->right))+1;
    
    return left;
}
```

## 2、左旋操作

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\21.二叉树.assets\v2-0a737f5850ac96deec1821c80391a08a_720w.jpg)

左旋操作和右旋操作十分类似，唯一不同的就是需要将左右互换下，可以认为两种操作是对称的。

```java
nodeptr_t treeRotateLeft(nodeptr_t root){
    nodeptr_t right = root->right;
    root->right = right->left;
    right->left = root;
    
    right->height = max(treeHeight(right->left),treeHeight(right->right)) + 1;
    root->height = max(treeHeight(root->left),treeHeight(root->right)) + 1;
    
    return right;
}
```

## 3、需要平衡的四种情况

https://blog.csdn.net/javazejian/article/details/53892797

进行旋转的目的是为了降低树的高度。

### （1）左左单旋转LL型，singleRotateLeft

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\21.二叉树.assets\aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYxMjMxMDgwOTE2ODAx.jfif)

左子树比右子树深2层，这种情况就是典型的LL情景，此时需要通过右向旋转来修复失衡的树。如图1，X经过旋转编程了图2，W变为根节点，X变为W的右子树，同时W的右子树变为X的左子树，树又重新回到平衡，各个节点的子树高度差已在正常范围内。一般情况下，我们把X节点称为失衡点，修复一棵被破坏的AVL树时，找到石恒典是很重要的并把通过一次旋转即可修复的平衡的操作叫做单旋转。从图3和图4可知，在原始AVL树插入7结点后，结点9变为失衡点，树再满足AVL性质，因此需要对9结点进行左左单旋转(即向右旋转)后，得到图4，我们发现此时并没有操作树的根结点(6)，实际上这是因为正常情况下，不必从树的根结点进行旋转，而是从插入结点处开始，向上遍历树，并更新和修复在这个路径上的每个结点的平衡及其平衡信息(高度)即可。

```java
/**
 * 左左单旋转(LL旋转) w变为x的根结点, x变为w的右子树
 * @param x
 * @return
 */
private AVLNode<T> singleRotateLeft(AVLNode<T> x){
    //把w结点旋转为根结点
    AVLNode<T> w=  x.left;
    //同时w的右子树变为x的左子树
    x.left=w.right;
    //x变为w的右子树
    w.right=x;
    //重新计算x/w的高度
    x.height=Math.max(height(x.left),height(x.right))+1;
    w.height=Math.max(height(w.left),x.height)+1;
    return w;//返回新的根结点
}
```

### （2）右右单旋转RR型，singleRotateRight

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\21.二叉树.assets\aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYxMjMxMDgzODAxODA2.jfif)

右右单旋转RR和左左单旋转LL的情况恰好是一种镜像关系，同样结点X并不能满足AVL树的性质，在这样的情景下，需要对X结点进行左旋转来修复树的平衡，如图1经左旋转后变了图2，此时X变为了根结点，W变为X的左孩子，X的左子树变为W的右子树，而树又重新恢复了平衡。如图3和图4的实例情景，原始的AVL树在12处插入结点18后，结点10就变成了失衡点，因为10的左子树和右子树的高度相差2，显然不符合AVL树性质，需要对结点10进行右右单旋转修复(向左旋转)，然后得到图4，此时树重新回到了平衡，这便是右右单旋转(RR)的修复情景。

```java
/**
 * 右右单旋转(RR旋转) x变为w的根结点, w变为x的左子树
 * @return
 */
private AVLNode<T> singleRotateRight(AVLNode<T> w){

    AVLNode<T> x=w.right;

    w.right=x.left;
    x.left=w;

    //重新计算x/w的高度
    w.height=Math.max(height(w.left),height(w.right))+1;
    x.height=Math.max(height(x.left),w.height)+1;

    //返回新的根结点
    return x;
}
```

### （3）左右双旋转LR型，doubleRotateWithLeft

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\21.二叉树.assets\aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYxMjMxMTA0MzIyNzQ1.jfif)

对于上图中的情景，如果子树Y太深，显然经过一次单旋转的修复后无论是X或者W作为根节点都无法符合AVL树的性质，此时就需要用双旋算法来实现了。由于子树Y是在插入一个节点后导致X节点的左右子树失去平衡，那么就说明子树肯定是非空的，因此为了易于理解，我们可以把子树看做一个根节点和两颗子树，如下图所示：

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\21.二叉树.assets\aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYxMjMxMTA0NTIwNjg0.jfif)

为了重新平衡，通过上述的分析显然不能把X作为根节点，而X与W间的旋转也解决不了问题，那唯一的旋转就是把Y作为新根。这样的话，X、W就不得不成为Y的孩子节点，其中W作为Y的左孩子节点，而X成为Y的右孩子节点。为了达到上述效果，需要W、Y进行单次旋转，这里我们可以把WY做成的子树看成前面的右右旋转RR情景，然后进行左向旋转，得到图2，W变为Y的右子树的同时Y的左子树B变成W的右子树，其他不变，到此一次旋转完成，进行第二次旋转，以X节点向右进行旋转（同样可看做左右情景），由图2得到图3，X变成Y的右孩子节点并且Y的右子树C变成X的左子树，第二次旋转完成，树也重新恢复到平衡。

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\21.二叉树.assets\aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYxMjMxMTA1NTEyNjIz.jfif)

在左右双旋转实例图123中，在原AVL树中插入节点7后，节点8变成了失衡点，此时需要把6节点变为根节点重新恢复平衡。因此先进行左向旋转再进行右向旋转，最后树恢复平衡。

```java
/**
 * 左右旋转(LR旋转) x(根) w y 结点 把y变成根结点
 * @return
 */
private AVLNode<T> doubleRotateWithLeft(AVLNode<T> x){
    //w先进行RR旋转
    x.left=singleRotateRight(x.left);
    //再进行x的LL旋转
    return singleRotateLeft(x);
}
```

### （4）右左双旋转RL型，doubleRotateWithRight

对于右左双旋转（RL）情景和左右双旋转（LR）情景是一对镜像，旋转的原理上是一样的。

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\21.二叉树.assets\aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMTA5MTIwMzA2ODc0.jfif)

```java
/**
 * 右左旋转(RL旋转)
 * @param w
 * @return
 */
private AVLNode<T> doubleRotateWithRight(AVLNode<T> x){
    //先进行LL旋转
    x.right=singleRotateLeft(x.right);
    //再进行RR旋转
    return singleRotateRight(x);
}
```

### （5）平衡二叉树插入操作

使用递归算法，根据值大小查找到插入位置，然后进行插入操作，插入完成后，我们需要进行平衡判断，评价子树是否需要进行平衡修复。最后记得重新计算插入节点路径上的高度。

```java
private AVLNode<T> insert(T data , AVLNode<T> p){
    // 说明已没有孩子节点，可以创建新节点插入了
    if(p==null){
        p = new AVLNode<T>(data);
    } else if(data.compareTo(p.data) < 0){
        // 如果当前值比p的值小，则向左插入
        p.left = insert(data,p.left);
        // 插入后计算子树的高度，等于2则需要重新恢复平衡，由于是左边插入，左子树的高度肯定大于等于右子树的高度
        if(height(p.left)-height(p.right)==2){
            // 表示插入在p.left的左边
        	if(data.compareTo(p.left.data)<0){
                // 进行LL旋转：向右旋转，只能以p为节点进行旋转
                p = singleRotateLeft(p);
            }else{
                // 表示在p.left的右边：先对p.left左旋转，再对p进行右旋转
                p = doubleRotateWithLeft(p);
            }
        }
    } else if(data.compareTo(p.data) > 0){
        // 向右子树寻找插入位置
        p.right = insert(data,p.right);
        if(height(p.right)-height(p.left)==2){
            if(data.compareTo(p.right.data)<0){
                // 进行右左旋转
                p = doubleRotateWithRight();
            } else {
                p = singleRotateRight(p);
            }
        }
    }
    p.height = Math.max(height(p.left),height(p.right)) + 1;
    return p;
}
```

### （6）平衡二叉树删除操作

删除节点后需要进行平衡检测，以便判断是否需要进行平衡修复，主要明白的是，这种实现方式在删除时效率并不高。如下是使用递归的形式表示删除数据的过程。找到不平衡的节点进行旋转。

```java
private AVLNode<T> remove(T data,AVLNode<T> p){
    if(p == null){
        return null;
    }
    int result = data.compareTo(p.data);
    // 从左子树查找需要删掉的元素
    if(result < 0){
        p.left = remove(data, p.left);
        // 检测是否平衡
        if(height(p.right)-height(p.left) == 2){
            AVLNode<T> currentNode = p.right;
            // 判断需要哪种旋转
            if(height(currentNode.left)>height(currentNode.right)){
                // RL 右左双旋转
                p = doubleRotateWithRight(p);
            } else {
                p = singleRotateRight(p);
            }
        }
    } else if(result > 0){
        p.right = remove(data,p.right);
        // 检测是否平衡
        if(height(current.right)-height(current-left) == 2){
            AVLNode<T> currentNode = p.left;
            // 判断需要哪种旋转
            if(height(currentNode.right)>height(currentNode.left)){
                // LR左右双旋转
                p = doubleRotateWithLeft(p);
            } else {
                // 左左单旋转LL
                p = singleRotateLeft(p);
            }
        }
    } else if(p.right != null && p.left != null){
        // 寻找替换节点
        p.data = findMin(p.right).data;
        // 移除用于替换的节点
        p.right = remove(p.data,p.right);
    } else {
        // 只有一个孩子节点或者只是叶子节点的情况
        p = (p.left != null)?p.left:p.right;
    }
    if(p!=null){
        p.height = Math.max(height(p.left), right(p.left)) + 1;
    }
    return p;
}

private AVLNode<T> findMin(AVLNode<T> p){
    if(p == null){
        // 结束条件
        return null;
    } else if(p.left == null){
        // 如果没有左节点，那么t就是最小的
    }
    return findMin(p.left);
}
```

### （7）最少节点数和最多节点数问题

假设AVL树的高度是h，N(h)表示高度为h的AVL树的节点数。对于最少节点数问题，是使用尽可能少的节点数来填充该树，现在假设左子树填充到的高度为h-1，根据AVL树的特征，右子树的高度只能填充到h-2，因此高度为h的AVL树的最小节点数为：N(h) = N(h-1)+N(h-2)+1，非常类似于斐波拉契序列。

最多节点数：获得最多节点数时，此时AVL树是一个完全二叉树，总节点数为$2^h-1$。

# 四、总结

作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度平衡。作为平衡二叉查找树，旋转是一个必不可少的操作。通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。

红黑树里面的插入和删除的操作比较难理解，这时要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的。在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入具体的分为3种情况，删除分为4种情况。

整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是logN。



# 五、树的遍历方法

用L代表左孩子，R代表右孩子，D代表根节点。为了简化，我们规定排序只能先左后右，所有就有三种排序方法

1）DLR（根左右）称为前根排序（前序）

2）LDR（左根右）称为中根排序（中序）

3）LRD（左右根）称为后根排序（后序）

![一颗二叉树](C:\Users\17646\Desktop\简历内容\Java知识储备\二叉树\一颗二叉树.png)

## 1.前序排序

首先访问二叉树的根节点，然后按照前根遍历规则访问左子树，如果所有的左子树都已遍历，则按照前根遍历的规则遍历右子树。如：按照前根排序的规定，对上图二叉树遍历结果为ABDIECFJGLM。

## 2.中序排序

首先按照中根顺序的规则访问二叉树的左子树，如果左子树都已遍历，则访问左子树的根节点，然后按中根遍历的规则访问二叉树的右子树。如图的遍历结果为：DIBEAJFCLGM

## 3.后序排序

首先根据后根遍历的规则访问二叉树的左子树，如果左子树都已遍历，则按后根遍历的规则访问二叉树的右子树，然后访问二叉树的根节点。如图的遍历结果为：IDEBJFLMGCA



# 六、二叉树分类

## 1.完全二叉树

对于一个树高为h的二叉树，如果其第0层至第h-1层的节点都满。如果最下面一层节点不满，则所有的节点在左边的连续排列，空位都在右边。这样的二叉树就是一棵完全二叉树。

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\10104523-a0740911374eb600.webp)

**完全二叉树最重要的性质：如果n个节点的完全二叉树的节点按照层次并按从左到右的顺序从0开始编号，对于人一个节点都有：**

- 序号为0的节点是根
- 对于*i>0*，其父节点的编号为*(i-1)/2*。
- 若*2·i+1<n*，其左子节点的序号为*2·i+1*，否则没有左子节点。
- 若*2·i+2<n*，其右子节点的序号为*2·i+2*，否则没有右子节点。

## 2.二叉搜索树，分类二叉树

分类二叉树又可以称为二叉排序树或二叉搜索树。从名称的多样性上就反应出分类二叉树是一种非常有意义的树。

一个典型的应用例子是，在大量数据的处理中，为了便于数据查找，对输入的数据采用分类二叉树的方式存储，可以大大提高查找的效率，其时间效率是$O(log_2^n)$。如果按中序遍历一棵分类二叉树，其结果是一个按某一特征值（关键字）排序的线性序列。按以下原则建立的二叉树称为分类二叉树：

- 每个元素有一个关键字（一般还限定任意两个元素的关键字都不相同，相同时构造分类二叉树再做另外约定）
- 根节点的左子树根的关键字（如果存在）小于根节点的关键字
- 根节点的右子树根的关键字（如果存在）大于根节点的关键字
- 根节点的左右子树也都是分类二叉树

例如，数据集合的关键字：{15,23,12,8,13,9,25,21,18}。按照**中序遍历**这棵分类二叉树，遍历结果为：{8,9,12,13,15,18,21,23,25}。构造分类二叉树的过程为：

![1555053452826](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\1555053452826.png)

## 3.哈夫曼树

节点间的路径：从树中一个节点到另一个节点之间的分支构成这两个节点之间的路径。两个节点间的分支数，就是这两个节点间的路径长度。

简单路径长度：从树的根节点到每个节点的路径长度之和。

如果将一棵二叉树汇中叶子节点看成是查找过程最终获取的信息，那么，中间的分支节点中存放的就是查找过程中选择查找方向的条件。叶子节点中的信息不同，被查找的频率就不同，使用频率越高的信息，重要性越高，也可以说其权值就越大。如果树中的每个叶子节点都有权值，即每个叶子节点的大小不同，中间分支节点的权值为0，那么从叶子节点到根节点之间的长度，就是**叶子的权值与叶子到根节点之间的路径长度（分支数）的乘积**，也称为叶节点的加权路径长度。

所谓树的加权路径长度，指树中所有带权（非0）叶节点的加权路径长度之和。

![1556200449497](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\1556200449497.png)

图4.69中的树加权路径长度为：$6*3+4*3+2*2+3*2=40$

图4.70中树的加权路径长度为：$2*3+3*3+6*2+4*2=35$

在实际应用中，检索频率高的信息在检索过程中，检索判断的次数应尽可能少，也就是说，检索频率高的信息存放在更靠近树根的位置上。检索频率高的信息就是检索概率大的信息，概率就是一个权值。大权值的节点如果更靠近根节点，检索树的检索效率就越高，也就是树的加权路径长度越小。

哈夫曼树（Huffman）的定义：哈夫曼树又称为最优二叉树。有n个节点，它们分别具有不同的权值，将这n个节点作为叶节点可以构造出m中不同的二叉树，这些二叉树具有不同的加权路径长度，则其中加权路径长度最小的二叉树称为最优二叉树或哈夫曼树。

有两种不同的方法构造哈夫曼树：

方法1：利用链表结构及二叉树结构构造哈夫曼树

方法2：利用堆来构造哈夫曼树

### （1）利用链表结构和二叉树结构构造哈夫曼树

首先将所有哈夫曼节点存储为一个简单链表，如下：

H -> 6 -> 2 -> 3 -> 3 -> 4 -> 9

然后对初始链表的节点调用排序算法，按权值从小到大地排序，产生如下结果：

H -> 2 -> 3 -> 3 -> 4 -> 6 -> 9

对这个有序的链表连续地删除表头的两个节点，但不释放其存储空间，即删除前面两个权最小的节点，并将这两个节点的权值相加，权值相加的和存储到新申请的一个哈夫曼节点的权值成员域中，并将删除的两个节点链接到新申请的哈夫曼节点的左、右孩子链接域上，成为一棵二叉子树，新申请的哈夫曼节点就是这个二叉子树的根。再将这个新哈夫曼节点重新插入到链表节点中，并保证链表是按权值大小有序排列的。

![1556207509294](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\1556207509294.png)

### （2）利用堆构造哈夫曼树

利用最小堆构造哈夫曼树的算法思想为：

1. 根据给定的n个权$w={w_1,2_2,...,w_n}$，构造n个对应的二叉树叶子节点
2. 定义一个堆数组heap，数组元素由两个数据项组成：权值域（$w_i$或$w_L+w_s$权值）和指向二叉树节点的链接域。初始化时，heap[i]的每个权值域为叶子节点权值$w_i$，链接域分别指向对应的二叉树孩子节点。
3. 对heap进行初始化堆运算
4. 重复下面的步骤n-1次：
   - 删除一个堆顶元素，并由L指向删除的堆顶元素节点
   - 再删除一个堆顶元素，并由R指向删除的堆顶元素节点
   - 将L和R所指的权值相加存放到新申请的由D指向的空间权值域中
   - 以D指的节点为根，L链接域所指的子树为左子树，R链接域所指的子树为右子树，构造一个新子树
   - 将合并的堆节点D插入堆heap中（删除两个节点，插入一个节点）
5. 释放heap堆节点空间
6. 返回哈夫曼树根节点指针

![1556211800147](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\1556211800147.png)

## 4.平衡二叉树

平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点总数的公式如下$ F(n)=F(n-1)+F(n-2)+1$ 这个类似于一个递归的数列，可以参考Fibonacci(斐波那契)数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。

平衡二叉树，是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。高度平衡？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。

将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。 

平衡二叉树的前提是它是一棵二叉排序树。 

距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。如下图所示，当插入结点37时，距离它最近的平衡因子的绝对值超过1的结点是58。

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\26548237_1358647849QBbO.png)

# 七、树相关知识补充

**B-tree树即B树**，B即Balanced，平衡的意思。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是另一种树。而事实上是，**B-tree就是指的B树**。特此说明。

先介绍下二叉搜索树：

- 所有非叶子结点至多拥有两个儿子（Left和Right）；

- 所有结点存储一个关键字；

- 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；

![](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\二叉搜索树.JPG)

二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；

如果二叉搜索树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变二叉搜索树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；

## 1.B树（B-树）

是一种多路搜索树（并不是二叉的）：

- 定义任意非叶子结点最多只有M个儿子；且M>2；

- 根结点的儿子数为[2, M]；

- 除根结点以外的非叶子结点的儿子数为[M/2, M]；

- 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）

- 非叶子结点的关键字个数=指向儿子的指针个数-1；

- 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；

- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；

- 所有叶子结点位于同一层；

如：（M=3）

![](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\B树.JPG)

 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

B-树的特性：

1.关键字集合分布在整颗树中；

2.任何一个关键字出现且只出现在一个结点中；

3.搜索有可能在非叶子结点结束；

4.其搜索性能等价于在关键字全集内做一次二分查找；

5.自动层次控制；

由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：

![](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\B树搜索性能推导.JPG)

其中，M为设定的非叶子结点最多子树个数，N为关键字总数；

所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；

## 2.B+树

B+树是B-树的变体，也是一种多路搜索树：

- 其定义基本与B-树同，除了：
- 非叶子结点的子树指针与关键字个数相同；
- 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
- 为所有叶子结点增加一个链指针，为顺序查找提供便利；
- 所有关键字都在叶子结点出现；
- 使用多叉是为了降低树的高度；

如：（M=3）

![](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\B+树.JPG)

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
B+的特性：

- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
- 不可能在非叶子结点命中；
- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
- 更适合文件索引系统；

应用场景：

MySQL中索引是用B+树，磁盘文件组织。

MySQL中为何使用B+树？

http://blog.codinglabs.org/articles/theory-of-mysql-index.html

- B+树的非叶子节点只是存储key，占用空间非常小，因此每一层的节点能索引到的数据范围更加广，每次IO操作可以观看到更多的数据。

- 叶子节点两两相连，符合磁盘的预读特性。如下图中存储50和55的叶子节点，它有个指针指向了60和62这个叶子节点，那么当我们从磁盘读取50和55对应的数据的时候，由于磁盘的预读特性，会顺便把60和62对应的数据读取出来。这个时候属于顺序读取，而不是磁盘寻道了，加快了速度。

  ![这里写图片描述](C:\Users\17646\Desktop\简历内容\Java知识储备\21.二叉树.assets\bb4c763b5dccbef0bc444aa009f375b1)

- 支持范围查询，而且部分范围查询非常高效，原因是数据都是存储在叶子节点这一层，并且有指针指向其他叶子节点，这样范围查询只需要遍历叶子节点这一层，无需整棵树遍历。

- 通常来说，B+树索引用于基于磁盘的数据库系统，即数据最后持久化存放在磁盘上，每个页的叶子节点一般包含较多的记录，因此具有较高的扇出。这意味着在数据库中B+树索引高度一般较小，在2~3层，其高度也决定了磁盘I/O搜索的次数

- 还有一点需要注意的是，实际上根据B+树索引并不能找到一个给定值的具体行，B+树索引能找到的只是查找数据行所在的页。然后数据库通过把数据页读入内存，再在内存中进行查找，最后得到查找的数据。

  

## 3.B\*树

 是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；

![](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\B树2.JPG)

B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

B\*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；所以，B*树分配新结点的概率比B+树要低，空间使用率更高；