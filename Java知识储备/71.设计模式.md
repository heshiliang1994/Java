设计模式

### 一、工厂模式

### 二、Adapt模式（适配器模式）

适配器模式：通过一个类的接口转换成客户希望的另外一个接口

在HTTPClient中

类org.apache.hc.client5.http.impl.classic.InternalHttpClient中有如下语句：

CloseableHttpResponse.adapt(response);



### 三、多线程设计模式 - Future模式

参考链接：https://juejin.im/post/5d1b2674f265da1bce3dea7f

Future模式是在多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。当我们需要调用一个函数方法时，如果这个函数执行很慢，那么我们就要进行等待。但有时候，我们可能并不着急要结果。因此，我们可以让被调用者立即返回，让他在后台慢慢处理这个请求。对于调用者来说，则可以先处理一些其他任务，在真正需要数据的场合再尝试获取需要的数据。

就像我们在网上购物，你买了一个包之后会给你生成一个电子的订单凭证，你只需要持有凭证等待包送过来就行了，这期间你可以做其他你想做的事情。

对于Future模式来说，它无法立即返回你需要的数据，但是它会返回一个契约，将来你可以凭借这个契约去获取你需要的信息。

#### 1.Future模式和非Future模式的区别

在传统的同步方法中调用一些耗时的程序，需要等待一个方法完成后才能进行下一步。而future模式中客户端调用完成后并不急于去做处理，而去调用其他的业务，这样充分利用了时间，这就是Future模式的核心。

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\71.设计模式.assets\16bb20e5f34c4699)

#### 2.Future模式的主要成员

- Main：系统启动，调用client发送请求
- Client：返回Data对象，立即返回FutureData，并开启ClientThread线程装配RealData
- Data：返回数据的接口
- FutureData：Future数据构造块，但是是一个虚拟的数据，需要装配RealData
- RealData：真实数据。

#### 3.Java中的使用方法

JDK内置的Future模式优化代码，首先要实现Callable这个接口，Data、FutureData、Client对象就不需要了。

```Java
public class RealData implements Callable<String> {
	private String para;

	public RealData(String para) {
		this.para = para;
	}

	//call中写具体的业务逻辑
	@Override
	public String call() throws Exception {
		//模拟真实业务逻辑，执行很慢
		StringBuffer buffer=new StringBuffer();
		System.out.println("RealData 正在构造真实数据。。。");
		for (int i=0;i<10;i++){
			buffer.append(para);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		System.out.println("RealData 真实数据构造完成。。。");
		return buffer.toString();
	}
}
```

在Main方法中，直接通过RealData构造FutureTask，作为单独的线程运行。

```java
public class Main {
	public static void main(String[] args) throws ExecutionException, InterruptedException {
		//构造FutureTask
		FutureTask<String> future=new FutureTask<String>(new RealData("name"));
		ExecutorService executor= Executors.newFixedThreadPool(1);
		//执行FutureTask,相当于client.request()发送请求
		//开启线程进行RealData的call()执行
		executor.submit(future);
		System.out.println("发送请求完毕");

		try {
			System.out.println("Main 正在调用其他业务逻辑。。。");
			Thread.sleep(2000);
			System.out.println("Main 其他业务处理完成。。。");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		//使用真实的数据
		//相当于data.getResult()，取得call()方法的返回值
		//如果call()方法没有执行完成，则依然会等待
		System.out.println("数据= " + future.get());
	}
}
```

Future模式的核心在于除了主函数中的等待时间，并使得原本需要等待的时间可以用于其他业务逻辑的处理，充分利用了计算机资源，提高系统性能。

### 四、多线程设计模式 - Master-Worker模式

Master-Worker是常用的并行模式之一，它的核心思想是：系统由两类进程协同工作，即Master进程和Worker进程，Master负责接收和分配数据，Worker负责处理子任务。当各个Worker进程将子任务处理完成后，将结果返回给Master进程，由Master进程进行汇总，从而得到最终的结果，具体处理过程如下图所示：

![http://img.blog.csdn.net/20141113102527554](C:\Users\17646\Desktop\简历内容\Java知识储备\71.设计模式.assets\20141113102527554)

Master-Worker模式的好处，它能够将一个大任务分解成若干小人物并行执行，从而提高系统的吞吐量。而对于系统请求者client来说，任务一旦提交，Master进程会分配任务并立即返回，并不会等待系统全部处理完成后再返回，其处理过程是异步的。因此，client不会出现等待现象。

#### 1、Master-Worker模式结构

Master-Worker模式的结构相对比较简单，Master进程为主要进程，它维护一个Worker进程队列、子任务队列和子结果集、Worker进程队列中的Worker进程，不停地从任务队列中提取要处理的任务，并将子任务的处理结果写入结果集。

![img](https://images2015.cnblogs.com/blog/980882/201702/980882-20170226231259991-550463638.png)



Master-Worker模式是一种使用多线程进行数据处理的结构。多个Worker进程协作处理用户请求，Master进程负责维护Worker进程，并整合最终处理结果。

