# 一、图的概念

## 1.无向图

由顶点和边组成，边不具备方线性。

## 2.有向图

由顶点和边组成，边有方向

## 3.完全图

图中的任意两个顶点之间都存在一条边，在一个含有n个顶点的无向完全图中，有n(n-1)/2条边

## 4.有向完全图

图中的任意两个顶点之间都存在一对方向相反的弧，在含有n个顶点的有向完全图中，有n(n-1)条边。



# 二、图的存储结构

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.图的存储结构.png)

## 1.邻接矩阵表示法

邻接矩阵表示法是一种简单的存储表示方法，它的优点是简单，缺点就是空间开销在某些情况下可能比较大，而且空间的利用率可能较低。这种表示法既适用于无向图，也适用于有向图。

这种方法的思想是，对于一个有n个顶点的图，就定义一个n阶矩阵，把各个顶点之间存在的和不存在的边都穷举出来。对于不存在的边，带权图和不带权图的实现有所差别。

无向图对应的邻接矩阵是对称的，有向图对应的邻接矩阵不一定对称。

## 2.邻接表表示法

对于图G中的某个顶点v<sub>i</sub>，把它相邻接的所有顶点（如果是有向图，则是所有邻接自该顶点的所有顶点）串起来，构成一个单链表，这个链表就称为顶点v<sub>i</sub>的邻接表。如果图G有n个顶点，那么就会得到n条邻接表。

为了有效地对这n条邻接表进行有效的管理，每条邻接表的前面都增设一个表头节点，所有的表头节点可以存储在一个数组中。为了避免各顶点信息的重复存储，可以规定各顶点的基本信息存放在表头节点中。如上图中的表示。

逆邻接表：可以有效地计算顶点的入度。概念基本上和邻接表一样，唯一的差别在于逆邻接表是把所有的邻接到某顶点的所有顶点串起来，构成一条单链。


## 3.十字链表

## 4.邻接多重表



# 三、图的遍历

图的遍历是从某个顶点出发，按某种顺序对图中的所有顶点各做一次访问。如果给定的图是连通图，则从图中任一顶点出发按照某种顺序就可以访问到该图的所有顶点。图的遍历方法主要有两种：深度优先搜索和广度优先搜索

## 1.深度优先搜索遍历

### 1）概念

深度优先搜索遍历（Depth_First Search, DFS）是按照如下步骤进行的：在图G中任选一顶点V<sub>i</sub>为初始出发点，首先访问出发点V<sub>i</sub>，并将其标记为已访问过，然后依次从V<sub>i</sub>出发搜索V<sub>i</sub>的每一个邻接点V<sub>j</sub>，若V<sub>j</sub>未曾访问过，则以V<sub>j</sub>为新的出发点继续进行深度优先搜索遍历。

显然上述搜索法是递归定义的，它的特点就是尽可能先对纵深方向进行搜索，所以称为深度优先搜索遍历。

## 2.广度优先搜索遍历

### 1）概念

宽度或广度优先搜索遍历（Breadth_First Search，BFS）是按照如下步骤进行的：在图G中任意选一顶点V<sub>i</sub>作为初始出发点，首先访问出发点V<sub>i</sub>，接着依次访问V<sub>i</sub>的所有邻接点Q<sub>1</sub>、Q<sub>2</sub>、Q<sub>3</sub>、...，然后再依次访问与Q<sub>1</sub>、Q<sub>2</sub>、Q<sub>3</sub>、...邻接的所有未曾访问过的顶点，依次类推，直至图中所有和初始出发点V<sub>i</sub>有路径相同的顶点都已访问到为止。

这种方法的特点就是以出发点为中心，一层一层地扩展开去，先对横向进行搜索，所以称为宽度优先搜索。



# 四、最小生成树

连通图的极小连通图，就是原图的生成树。由生成树的定义可知，无向连通图的生成树不是唯一的。连通图的一次遍历所经过的边的集合及图中所有顶点的集合就构成了该图的一颗生成树，对连通图的不同遍历，就可能得到不同的生成树。

假设图G有n个顶点，图T是图G的生成树，那么图T肯定具备n个顶点和n-1条边。如果图T少于n-1条边，那么它肯定不是连通的；如果图T有多于n-1条边，那么它肯定不是极小连通子图，图中存在回路；但是也不能说具备n个顶点和n-1条边的图都是图G的生成树，因为他们不一定是图G的极小连通子图。

求连通图的生成树，可以用前面介绍的深度优先搜索算法或广度优先搜索算法来实现，得到分别称为深度优先生成树和宽度优先生成树。

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.连通子图 最小生成树.png)



## 1.最小代价生成树

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.最小代价生成树.png)

### 1）最小代价生成树

图5.30给出了各个城市之间的直线距离，现在想在这几个城市之间铺设电话线，要求任意两个城市之间能够通话，而且电话线的长度最短。如果把它看成一个图，该图的生成树是能够保证任意两个城市之间可以通话的方案，而且电话线的条数最少。但实际要求的是电话线的总长度最短，这就需要在众多生成树中寻找一个最适合的，方法就是找出所有生成树各边权值之和，最小者就是满足条件的方案。

最小代价生成树：对于带权的连通图，各边权值之和的最小的生成树称为该图的最小代价生成树。

### 2）Prim算法

Prim算法可以求解出给定连通网络的最小代价生成树。基本思路如下：

假设连通网络G={V, E}，图T={U, ME}是图G的最小代价生成树，求图T的步骤如下：

（1）令U={u<sub>0</sub>}，ME={$\Phi$}，$u_0$是集合V中的任意一个顶点。

（2）**在所有的$u\in U$,$v\in (V-U)$，而且$(u,v)\in E$的边，找一条权最小的边$(u_i, v_i)$**，将$v_i$并入集合U，将边$(u_i, v_i)$并入集合ME。（这个地方是取的是U中已经有的顶点到剩下未加入到U中顶点边权重最小的值）

（3）重复步骤（2），直到U=V。

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.Prim求解最小代价生成树.png)

本算法的时间复杂度为$O(n^3)$。

### 3）Kruskal算法

Kruskal算法也可以求解出给定连通网络的最小代价生成树。它的基本思路如下：

假设连通网G={V, E}，图T是图G的最小代价生成树，求解图T的步骤如下：

（1）令$T=\{V, \{\Phi\}\}$，也就是说，T最初由n个顶点和0条边构成。

（2）在E中选择权最小的一条边，如果该边加入到T中之后会形成回路，则放弃该边，在其余的边中再找权最小的一条边。

（3）将该边从E中删除，加入到图T的边集中去。

（4）重复步骤（2）和（3），知道图T中包含n-1条边。

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.Kruskal求解最小代价生成树.png)



# 五、最短路径

## 1.单源最短路径——Dijkstra算法

从某个顶点出发，到达其他所有顶点的最短路径，称为单源最短路径。开始顶点称为源顶点，路径上的最后一个顶点称为终点。

Dijkstra算法可以求解源点到其余各顶点的最短路径。基本思想如下：

假设图G={V, E}，从顶点$V_0$出发，计算到达其他所有顶点的最短路径。假设图G采用邻接矩阵存储，矩阵本身存储在数组data\[][]中，定义集合S为已经求出的距离顶点$V_0$最短的顶点的集合，那么集合V-S就是待计算的顶点集合。定义数组dist[]中保存顶点$V_0$到各顶点的当前最短路径，

（1）令S={$V_0$}。

（2）令dist[i]=data\[$V_0$][i]，i是除顶点$V_0$以外的其余各顶点的序号。

（3）从V-S中选取一个dist[]值最小的顶点v，把顶点v加入到集合S中去，再对集合V-S中的每个顶点i，令$dist[i]=min\{dist[i], dist[v]+data[v][i]\}$。表示取“已有的顶点$V_0$到顶点i的距离”和“经过顶点V，再到i，顶点$V_0$到i的距离”的最小值

（4）重复步骤（3），直到S=V。

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.Dijkstra单源最短路径求解过程.png)



## 2.任意两个顶点之间的路径 - Floyed算法

如果要求任意两个顶点之间的最短路径，可以依次把每个顶点当做源点，调用Dijkstra算法即可。接下来介绍另外一种更简洁的算法：Floyed算法（动态规划）。

获得任意点i到任意点j的最短路径不外乎两种。一种是从i直接到j，即$A[i][j]$，另外一种是i经过若干节点k到j，即$A[i][k]+A[k][j]$，其中$A[i][k]$表示的就是i到k的最短距离，$A[j][k]$表示的就是k到j的最短距离。

假定网络G用邻接矩阵表示，矩阵本身用数据data\[][]表示。和前面讲述的邻接矩阵不一样的是，这里要求矩阵的所有行列号相等的元素值都为0。

Floyed算法的基本思想是递归地产生矩阵序列$A_0、A_1、A_2、A_3，...，A_n$，矩阵$A_k（k=0,1,2,...）$的元素$A_k[i][j]$为从顶点i到顶点j且中间不经过编号大于k的顶点的最短路径长度，$A_{n-1}$就是最终的运算结果。

令$A_{-1}[i][j]=data[i][j]$，它表示从顶点i到顶点j且中间不经过任何顶点的最短路径长度，也就是最原始的直线距离。

然后在所有的路径中增加中间顶点$V_0$，如果新得到的路径长度小于原来的路径长度，那么就以新路径替代老路径。也就是对于每一个矩阵元素$A_0[i][j]$进行计算，$A_0[i][j]=min\{A_{-1}[i][j], A_{-1}[i][0]+A_{-1}[0][j]\}$。

接着，在所有的路径中增加中间顶点$V_0$，如果新得到的路径长度小于原来的路径长度，那么就以新路径替代老路径，也就是对于每一个矩阵元素$A_1[i][j]$进行计算，$A_1[i][j]=min\{A_0[i][j], A_0[i][1]+A_{-1}[1][j]\}$。以此类推，直到加入所有的顶点，最后得到的矩阵就是运算结果。

状态转移方程为：$A_1[i][j]=min\{A_0[i][j], A_0[i][1]+A_{-1}[1][j]\}$

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.Floyed求解最短路径.png)