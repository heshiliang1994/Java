![img](https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54pze4cQdXwM6ibfGzypdpGhKAx35wxBTnwHfS2cBJv3hFgtEmRiaoRQx2PbsMD9DttUY5puQMhlBhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

https://mp.weixin.qq.com/s/t0dsJeN397wO41pwBWPeTg

- n: 数据规模
- k: “桶”的个数
- In-place: 占用常数内存，不占用额外内存
- Out-place: 占用额外内存
- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
- **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
- **内排序**：所有排序操作都在内存中完成；
- **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
- **时间复杂度：** 一个算法执行所耗费的时间。
- **空间复杂度**：运行完一个程序所需内存的大小。

插入排序法是一种由初始空集合开始，不断地把记录插入到合适位置的排序方法。通常的插入排序法有直接插入排序和希尔排序。希尔排序并不是直接意义上的插入排序，而是希尔排序的分组概念上的插入排序，即在不断缩小组的个数时，把原各组的记录插入到新组的合适位置中。

# 一、直接插入排序

直接插入排序的思想是：顺序地把待排序序列中的各个记录按其关键字的大小插入到已排序的序列的适当位置。

假设待排序序列为$R_1、R_2、...、R_n$，开始排序时，认为序列中的第一个记录已经排好序，它组成了排序的初始序列；现在将第二个记录的关键字与第一个记录的关键字进行比较，若$R_1.key>R_2.key$，则交换两个记录的位置，否则不交换，这样就将第二个记录插入到了已排序的序列中。以此类推，对序列中的第i个记录$R_i$排序时，$R_i$前面的i-1个记录已经组成了有序序列$R_1^′、R_2^′、...、R_{i-1}^′$，将$R_i.key$依次与$R_1^′.key、R_2^′.key、...、R_{i-1}^′.key$进行比较，找出一个适合的$j（1 \leq j \leq i-1）$，使得$R_{i-1}^′.key \leq R_i^′.key \le R_j^′.key$，然后把记录$R_j^′、...、R_{i-1}^′$全部顺序地后移一个位置，将$R_i$放到j位置上，就完成了序列中第i个记录的插入排序。当完成了对序列第n个记录$R_n$的插入后，整个序列排序完毕。

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.快速排序.gif)

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.插入排序.png)

```Java
// Java实现直接插入排序
for (int i = left, j = i; i < right; j = ++i) {
	int ai = a[i + 1];
	while (ai < a[j]) {
		a[j + 1] = a[j];
		if (j-- == left) {
			break;
		}
		}
	a[j + 1] = ai;
}
```

# 二、希尔排序

希尔排序又称缩小增量排序，它的基本思想是：不断把待排序的记录分成若干小组，对同一组内的记录进行排序，在分组时，始终保证当前组内的记录个数超过前面分组排序时组内的记录个数。

希尔排序的具体做法是：先设置一个整数量$d_1$，称之为增量，将待排序的记录序列中所有距离为$d_1$的记录放在同一组中。例如，若$d_1=5$，则记录$R_1,R_6,R_{11},...$放在同一组中，记录$R_2,R_7,R_{12},...$放在另一组中，以此类推。然后对各组内的记录分别进行排序，这样的一次分组排序过程称为一次排序。再设置另一个新的增量$d_2$，使$d_2<d_1$，采用上述相同的方法进行第二次排序，如此进行下去，当最后一次排序时，设置的增量是$d_1=1$时，表明序列中全部记录放在了同一组中，该次排序结束时，整个序列的排序工作完成。在希尔排序的各次排序过程中，组内记录的排序可以采用直接插入排序法，也可以采用其他合适的方法。

希尔排序实际上是对插入排序法的一种改进。通过分析直接插入排序算法可以知道，当待排序的序列中记录个数比较少或者序列接近有序时，直接插入排序算法的效率比较高，希尔排序正是基于这两点考虑的。开始排序时由于选取的增量值比较大，各组内的记录个数相对来讲比较少，所以各组内的排序速度比较快。在以后的各次排序时，尽量增量值逐渐变小，各组内的记录个数逐渐增多，但由于前面的各次排序已经使得组内的记录越来越接近有序，所以各组内的排序速度也比较快。

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.希尔排序.png)

希尔排序适用于中等规模的记录序列排序的情况。时间复杂度为不知道。。。	

# 三、归并排序

归并排序（Merge sort）是一种常用的排序方法。最经常使用的是归并排序方法是二路归并排序。二路归并的含义是把两个有序的序列合并为一个有序的序列。

二路归并排序的思路是：将有n个记录的原始序列看做n个有序子序列，每个子序列的长度为1，然后从第一个子序列开始，把相邻的子序列两两合并，得到$\lceil n/2 \rceil$个长度为2或1的子序列（当子序列个数为奇数时，最后一组合并得到的序列长度为1），我们把这一过程称为一次归并，对第一次归并排序后的$\lceil n/2 \rceil$个子序列采用上述方法继续顺序成对归并，如此重复，当得到长度为n的一个子序列时，该子序列便是原始序列归并排序后的有序序列。

## 1.两个有序序列的合并

设有两个有序序列$L_1$和$L_2$，它们顺序存放在数组$r[l_1],..,r[u_1]$和$r[l_2],..,r[u_2]$中，其中$l_2=u_1+1$。它们所对应的关键字序列为$(K_{l_1},...,K_{u_1})$和$(K_{l_2},...,K_{u_2})$。若两个序列归并的结果放在数组Swap的同样位置上，即$Swap[l_1],...,Swap[u_2]$中，则归并的方法可描述如下：

设置三个变量i,j,m，其中i,j分别表示序列$L_1$和$L_2$中当前要比较的记录的位置号，初值$i=l_1,j=l_2$，m表示数组Swap中当前记录防止的位置号，初值为$m=l_1$。归并时，反复比较$K_i$和$K_j$的值：

（1）若$K_i \leq K_j$，则$r[i] \rightarrow Swap[m]，i=i+1，m=m+1$

（2）若$K_i \gt K_j$，则$r[j] \rightarrow Swap[m]，j=j+1，m=m+1$

当序列$L_1$或$L_2$中的全部记录已归并到数组Swap中，即$i=u_1+1$或$j=u_2+1$时，比较结束。然后将另一个序列中剩余的所有记录依次存放到数组Swap中，这样就完成了有序序列$L_1$和$L_2$的合并。如下图：

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.二路归并排序.png)

## 2.二路归并排序

二路归并排序就是对原始序列进行若干次二路归并排序。在每次二路归并排序中，子序列的长度为上一次子序列长度的2倍，当子序列的长度大于等于n时，排序结束。

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.二路归并排序例子.png)

![img](https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk54pze4cQdXwM6ibfGzypdpGhxYKgvQDqXLlUSvfPlNBAmlibd9TORFdcHandRCdXYayiaJyibaJA2Wrmw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

算法的时间复杂度为$O(nlogn)$

# 四、冒泡排序

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

## 1.算法描述：

- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。

![img](https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk54pze4cQdXwM6ibfGzypdpGhJDtkjEsfeP4U7O4zyrASg7YCxZibE4uiaA705VJnGtafy7ibv8xzZkhXQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

## 2.举例

| 初始关键字序列 | 38   | 5    | 19   | 26   | 49   | 97   | 1    | 66   |
| -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 第一次排序结果 | 5    | 19   | 26   | 38   | 49   | 1    | 66   | [97] |
| 第二次排序结果 | 5    | 19   | 26   | 38   | 1    | 49   | [66  | 97]  |
| 第三次排序结果 | 5    | 19   | 26   | 1    | 38   | [49  | 66   | 97]  |
| 第四次排序结果 | 5    | 19   | 1    | 26   | [38  | 49   | 66   | 97]  |
| 第五次排序结果 | 5    | 1    | 19   | [26  | 38   | 49   | 66   | 97]  |
| 第六次排序结果 | 1    | 5    | [19  | 26   | 38   | 49   | 66   | 97]  |
| 第七次排序结果 | 1    | 5    | 19   | 26   | 38   | 49   | 66   | 97   |

## 3.算法分析

最佳情况：T(n) = O(n)   最差情况：T(n) = O($n^2$)   平均情况：T(n) = O($n^2$)



# 五、选择排序

选择排序的基本思想是：不断从待排序的序列中选取关键字最小的记录放到已排序的记录序列的后面，直到序列中所有记录都已排序为止。常用的选择排序方法是直接选择排序和堆排序。堆排序是一种时间复杂度为$O(n(log_2n))$的排序算法。

## 1.直接选择排序

直接选择排序的做法是：从待排序的所有记录中，选取关键字最小的记录并将它与原始序列中的第一个记录交换位置；然后去掉关键字最小的记录的剩下记录中，选择关键字最小的记录并将它与原始序列中第二个记录交换位置，如此重复下去，直到序列中全部记录排序完毕。

时间复杂度为$O(n^2)$，直接排序是一种稳定的排序方法，空间复杂度为常数及$O(1)$。

![img](https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk54pze4cQdXwM6ibfGzypdpGhWVia3IR3gNaNYr7Opct15gUM3xmetFhMAYpgU1eTsic82dy684DwKElQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

## 2.堆排序

**堆：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。**

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182750011-675658660.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182857323-2092264199.png)

**堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了**

![img](https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk54pze4cQdXwM6ibfGzypdpGhspZvurhXd2nGGzNJEEJ9SZibcXIYtbx8f4YVpdhOqUjaYSOryO65IlQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。

　　a.假设给定无序序列结构如下

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png)

2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，**第一个非叶子结点 arr.length/2-1=5/2-1=1**，也就是下面的6结点），从左至右，从下至上进行调整。

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png)

4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png)

这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png)

此时，我们就将一个无需序列构造成了一个大顶堆。

**步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**

a.将堆顶元素9和末尾元素4进行交换

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png)

b.重新调整结构，使其继续满足堆定义

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png)

c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152929339-1114983222.png)

后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png)

再简单总结下堆排序的基本思路：

**- 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;**

**- 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

**- 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**

# 六、快速排序

快速排序又叫做分区交换排序，是目前已知的平均速度最快的一种排序方法，它是对冒泡排序方法的一种改进。

其基本思想是：从待排序的n个记录中任意选取一个记录$R_i$（通常选取序列中的第一个记录）作为标准，调整序列中各个记录的位置，使排在$R_i$前面的记录的关键字都小于$R_i.key$，排在$R_i$后面的记录的关键字都大于等于$R_i.key$，我们把这样的一个过程称作一次快速排序。在第一次快速排序中，确定了所选取的记录$R_i$最终在序列中的排列位置，同时把剩余的记录分成了两个子序列。这两个子序列分别进行快速排序，又确定了两个记录在序列中应处的位置，并将剩余记录分成了四个子序列。如此重复下去。当各个子序列的长度为1时，全部记录排序完成。

快排的时间复杂度为$O(nlog_2n)$。

下面先介绍第一次快速排序的方法。

设置两个变量i,j，他们的初值为当前排序的子序列中第一个记录的位置号low和最后一个记录的位置号high。将第一个记录作为标准记录放到一个临时变量Temp中，使它所占的位置腾空，然后从子序列的两端开始逐步向中间扫描，在扫描的过程中，变量i,j分别代表当前扫描到的左右两端记录在序列中的位置号。

（1）在序列的右端扫描时，从序列的当前右端开始，把标准记录的关键字与记录$R_j$（右端）的关键字相比较，若前者小于或等于后者，则令$j=j-1$，继续进行比较，如此下去，直到标准记录的关键字大于$R_j.key$或者$i=j$（此时所有位置号大于j的记录的关键字都大于标准记录的关键字）。若$i<j$，则将记录$R_j$放到腾空的位置上，使得$R_j$腾空，同时i加1，然后继续进行步骤（2），从序列的当前左端开始比较。

（2）在序列的左端扫描时，从序列的当前左端i处开始，将标准记录的关键字与$R_i$的关键字相比较，若前者大于后者，令$i=i+1$，继续进行下去，直到标准关键字小于$R_i.key$或者$i=j$（次数所有位置号小于i的记录的关键字都小于标准记录的关键字）。若$i<j$，则将记录$R_i$放到腾空的位置上，使$R_i$腾空，同时j减1，继续进行步骤（1），再从序列右端开始比较。

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.第一次快速排序.png)

![](C:\Users\17646\Desktop\简历内容\Java知识储备\42.快排结果.png)



![img](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\640.gif)

Java实现快速排序：

```Java
package sort;

/*
 * 快速排序
 * */
public class FastSort {
	public static void main(String[] args) {
//		int[] arr = {5,4,3,2,1};
		int[] arr = {12,20,5,16,1,30,45};
		sort(arr,0,arr.length-1);
		for(int a:arr)
			System.out.print(a+" ");
		System.out.println();
	}
	
	public static void sort(int[] arr,int start,int end){
		if(start>=end)
			return;
		int left = start;
		int right = end;
		int val = arr[left];
		
		while(left<right){
			while(left<right && arr[right] >= val) right --;
			// 当前这个值不满足上述条件了
			if(left<right) arr[left++] = arr[right];// right位置的值比val小，则将right位置的值挪到left位置上
			while(left<right && arr[left] <= val ) left ++;
			if(left<right) arr[right--] = arr[left];// left位置的值比val大，则将left位置的值挪到right位置上
		}
		// 通过一次排序，left处左边为小于val，右边为大于val的数据。
		arr[left] = val;
		sort(arr,start,left-1);
		sort(arr,left+1,end);
	}
}
```



# 七、计数排序

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。

算法思路为：

- 找出待排序的数组中最大和最小的元素；
- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

![img](https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk54pze4cQdXwM6ibfGzypdpGhplvOJtrbtIBISsZrzsgJ9Gk5ic8hebrrXdFaicurS0ibp6PFr37gnypLw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)



# 八、桶排序

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。

桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排。

算法描述：

- 人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；
- 遍历输入数据，并且把数据一个一个放到对应的桶里去；
- 对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；
- 从不是空的桶里把排好序的数据拼接起来。 

**注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。**

![img](https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54pze4cQdXwM6ibfGzypdpGhzTEjrYlxXz3pwq5YlP4AQMNvZGLuFQ0hPdsOMB0GicgDLlbASGsAHMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

# 九、基数排序

基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。

算法描述：

- 取得数组中的最大数，并取得位数；

- arr为原始数组，从最低位开始取每个位组成radix数组；

- 对radix进行计数排序（利用计数排序适用于小范围数的特点）；

![img](https://mmbiz.qpic.cn/mmbiz_gif/fEsWkVrSk54pze4cQdXwM6ibfGzypdpGhOhBNCPJibWnC02aicwO2xnIicYws6SS5Ob8AL5bvkFEkFQgFcCia0AIAlw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

  

**基数排序 vs 计数排序 vs 桶排序**

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

- 基数排序：根据键值的每位数字来分配桶
- 计数排序：每个桶只存储单一键值
- 桶排序：每个桶存储一定范围的数值

# 十、堆

最大树：最大树就是每个节点的值都大于或等于其他孩子节点的（如果存在）值的一般树（或二叉树）。

最小树：最小树就是每个节点的值都小于或等于其他孩子节点的（如果存在）值的一般树（或二叉树）。

Java中PriorityQueue就是一个最小堆。

关于树的高度和深度：

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\20180209101100736.png)

换句话讲，最大树中根（或子树的根）节点的值，是这棵树（子树）中最大的节点值；最小树中根（或子树的根）节点的值，是这棵树（子树）中的最小的节点值。

## 1.堆树

堆树简称为堆，是一棵二叉树，并且堆有如下特征：

堆树是一棵完全二叉树，如果一棵完全二叉树本身又满足最大树的条件，则这棵完全二叉树就是最大堆；如果一棵完全二叉树本身又满足最小树的条件，则这棵完全二叉树就是最小堆。

**堆的一些性质**：

树的*高度*是指从树的根节点到最低的叶节点所需要的步数，或者更正式的定义：高度是指节点之间的边的最大值。**一个高度为 h 的堆有 h+1 层**。

下面这个对的高度是3，所以它有4层：

![img](C:\Users\17646\Desktop\简历内容\Java知识储备\assets\4064751-9a3b75e40d3f9f04.webp)

如果一个堆有 n 个节点，那么它的高度是 *h = floor(log2(n))*。这是因为我们总是要将这一层完全填满以后才会填充新的一层。上面的例子有 15 个节点，所以它的高度是 `floor(log2(15)) = floor(3.91) = 3`。

如果最下面的一层已经填满，那么那一层包含 *2^h* 个节点。树中这一层以上所有的节点数目为 *2^h - 1*。同样是上面这个例子，最下面的一层有8个节点，实际上就是 `2^3 = 8`。前面的三层一共包含7的节点，即：`2^3 - 1 = 8 - 1 = 7`。

所以整个堆中的节点数目为：*2^(h+1) - 1*。上面的例子中，`2^4 - 1 = 16 - 1 = 15`

叶节点总是位于数组的 *floor(n/2)* 和 *n-1* 之间。

对于某个非叶子节点i，它的左孩子为$i*2+1$，右孩子为$i*2+2$，它的父节点为$(i-1)/2$

## 2.构建堆树的实现：

Java中PriorityQueue中采用的就是最小堆。

```Java
package sort;

/*
实现堆排序
*/
public class HeapSort {

	public static void main(String[] args) {
		int arr[] = {1,2,3,4,5,6};
		initHeap(arr);
		// for(int a:arr) System.out.print(a+" ");
		// System.out.println();
		for(int i=arr.length-1;i>=0;i--){
			deleteNode(arr,i);
		}
		for(int a:arr) System.out.print(a+" ");
		System.out.println();
	}
	
	// 初始化大顶堆
	public static void initHeap(int[] arr){
		int p = 0;
		for(int i=arr.length/2-1;i >=0;i--){
            // 假设二叉树有h层，则找h-1层的非叶子节点开始调整
			p = arr[i];
			int son = left(i);//左孩子
			while(son<=arr.length-1){
				// 表示此时有右孩子，且右孩子比左孩子大，注意是if判断。
				if(son<arr.length-1 && arr[son]<arr[son+1])
					son ++;
				if(p>arr[son])
					break;
				// 用孩子节点中的最大值替换到父节点的值，并向下寻找
				arr[parent(son)] = arr[son];
				son = left(son);
			}
			arr[son/2] = p;
		}
	}
	// 从大顶堆中删除节点，返回大顶堆的最大值
	public static int deleteNode(int[] arr,int len){
		// 将最大值挪到数组最后，交换值
		int root = arr[0];
		arr[0] = arr[len];
		arr[len] = root;
		// 调整大顶堆的结构
		int son = left(0);
		int p = arr[0];
		while(son <= len-1){
			// 表示当前有右孩子，且右孩子比左孩子大
			if(son<len-1 && arr[son]<arr[son+1])
				son ++;
			if(p>arr[son])
				break;
			arr[parent(son)] = arr[son];
			son = left(son);
		}
		arr[son/2] = p;
		return root;
	}
	
	// 获得节点i的左、右、父节点
	public static int left(int i){
		return 2*i+1;
	}
	public static int right(int i){
		return 2*i+1;
	}
	public static int parent(int i){
		return (i-1)/2;
	}
}
```

